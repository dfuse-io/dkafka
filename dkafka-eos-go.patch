Index: fork/eos-go/abidecoder.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fork/eos-go/abidecoder.go b/fork/eos-go/abidecoder.go
--- a/fork/eos-go/abidecoder.go	(revision 992d17e956c5221d392ad937f0646606994ce8a6)
+++ b/fork/eos-go/abidecoder.go	(revision fdf90d0e3ce369b8c2a6e25210ff62827bcac315)
@@ -12,6 +12,8 @@
 	"go.uber.org/zap"
 )
 
+var NativeType = true
+
 func (a *ABI) DecodeAction(data []byte, actionName ActionName) ([]byte, error) {
 	binaryDecoder := NewDecoder(data)
 	action := a.ActionForName(actionName)
@@ -43,8 +45,7 @@
 }
 
 func (a *ABI) DecodeTableRowTyped(tableType string, data []byte) ([]byte, error) {
-	binaryDecoder := NewDecoder(data)
-	builtStruct, err := a.decode(binaryDecoder, tableType)
+	builtStruct, err := a.DecodeTableRowTypedNative(tableType, data)
 	if err != nil {
 		return nil, err
 	}
@@ -52,7 +53,7 @@
 
 }
 
-func (a *ABI) DecodeTableRowTyped2Map(tableType string, data []byte) (map[string]interface{}, error) {
+func (a *ABI) DecodeTableRowTypedNative(tableType string, data []byte) (map[string]interface{}, error) {
 	binaryDecoder := NewDecoder(data)
 	return a.decode(binaryDecoder, tableType)
 }
@@ -333,20 +334,33 @@
 	case "time_point":
 		timePoint, e := binaryDecoder.ReadTimePoint() //todo double check
 		if e == nil {
-			value = formatTimePoint(timePoint, a.fitNodeos)
+			if NativeType {
+				value = time.Unix(0, int64(timePoint*1000)).UTC()
+			} else {
+				value = formatTimePoint(timePoint, a.fitNodeos)
+			}
 		}
 		err = e
 	case "time_point_sec":
 		timePointSec, e := binaryDecoder.ReadTimePointSec()
 		if e == nil {
-			t := time.Unix(int64(timePointSec), 0)
-			value = t.UTC().Format("2006-01-02T15:04:05")
+			t := time.Unix(int64(timePointSec), 0).UTC()
+			if NativeType {
+				value = t
+			} else {
+				value = t.UTC().Format("2006-01-02T15:04:05")
+			}
 		}
 		err = e
 	case "block_timestamp_type":
 		value, err = binaryDecoder.ReadBlockTimestamp()
 		if err == nil {
-			value = value.(BlockTimestamp).Time.UTC().Format("2006-01-02T15:04:05")
+			t := value.(BlockTimestamp).Time.UTC()
+			if NativeType {
+				value = t
+			} else {
+				value = t.Format("2006-01-02T15:04:05")
+			}
 		}
 	case "name":
 		value, err = binaryDecoder.ReadName()
@@ -405,23 +419,17 @@
 }
 
 func analyzeFieldType(fieldType string) (typeName string, isOptional bool, isArray bool, isBinaryExtension bool) {
-	if strings.HasSuffix(fieldType, "[]$") {
-		return fieldType[0 : len(fieldType)-3], false, true, true
+	if isBinaryExtension = strings.HasSuffix(fieldType, "$"); isBinaryExtension {
+		fieldType = fieldType[0 : len(fieldType)-1]
 	}
-
-	if strings.HasSuffix(fieldType, "?") {
-		return fieldType[0 : len(fieldType)-1], true, false, false
+	if isOptional = strings.HasSuffix(fieldType, "?"); isOptional {
+		fieldType = fieldType[0 : len(fieldType)-1]
 	}
-
-	if strings.HasSuffix(fieldType, "$") {
-		return fieldType[0 : len(fieldType)-1], false, false, true
+	if isArray = strings.HasSuffix(fieldType, "[]"); isArray {
+		fieldType = fieldType[0 : len(fieldType)-2]
 	}
-
-	if strings.HasSuffix(fieldType, "[]") {
-		return fieldType[0 : len(fieldType)-2], false, true, false
-	}
-
-	return fieldType, false, false, false
+	typeName = fieldType
+	return
 }
 
 const standardTimePointFormat = "2006-01-02T15:04:05.999"
Index: fork/eos-go/abidecoder_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fork/eos-go/abidecoder_test.go b/fork/eos-go/abidecoder_test.go
--- a/fork/eos-go/abidecoder_test.go	(revision 2db8b323cf5e74c5b100e2a56cc02c229c58a06c)
+++ b/fork/eos-go/abidecoder_test.go	(revision 85c709f0414f31100949a0c51d88fd7beac839ef)
@@ -1196,7 +1196,12 @@
 		{"field.type.1", "field.type.1", false, false, false},
 		{"field.type.1?", "field.type.1", true, false, false},
 		{"field.type.1[]", "field.type.1", false, true, false},
+		{"field.type.2[]?", "field.type.2", true, true, false},
 		{"field.type.1$", "field.type.1", false, false, true},
+		{"field.type.1?$", "field.type.1", true, false, true},
+		{"field.type.1[]$", "field.type.1", false, true, true},
+		{"field.type.3[]?$", "field.type.3", true, true, true},
+		{"uint32?$", "uint32", true, false, true},
 	}
 
 	for i, test := range testCases {
Index: fork/eos-go/types.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fork/eos-go/types.go b/fork/eos-go/types.go
--- a/fork/eos-go/types.go	(revision 83930a5861d582c39ddd4d6919fc489dba477952)
+++ b/fork/eos-go/types.go	(revision 85c709f0414f31100949a0c51d88fd7beac839ef)
@@ -22,6 +22,8 @@
 var symbolRegex = regexp.MustCompile("^[0-9],[A-Z]{1,7}$")
 var symbolCodeRegex = regexp.MustCompile("^[A-Z]{1,7}$")
 
+var LegacyJSON4Asset = false
+
 // For reference:
 // https://github.com/mithrilcoin-io/EosCommander/blob/master/app/src/main/java/io/mithrilcoin/eoscommander/data/remote/model/types/EosByteWriter.java
 
@@ -581,7 +583,17 @@
 }
 
 func (a Asset) MarshalJSON() (data []byte, err error) {
-	return json.Marshal(a.String())
+	if LegacyJSON4Asset {
+		return json.Marshal(a.String())
+	} else {
+		ratAmount := big.NewRat(int64(a.Amount), int64(math.Pow10(int(a.Symbol.Precision))))
+		amount, _ := ratAmount.Float64()
+		return json.Marshal(map[string]interface{}{
+			"amount":    amount,
+			"symbol":    a.Symbol.Symbol,
+			"precision": a.Symbol.Precision,
+		})
+	}
 }
 
 type Permission struct {
Index: fork/eos-go/types_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fork/eos-go/types_test.go b/fork/eos-go/types_test.go
--- a/fork/eos-go/types_test.go	(revision 83930a5861d582c39ddd4d6919fc489dba477952)
+++ b/fork/eos-go/types_test.go	(revision 85c709f0414f31100949a0c51d88fd7beac839ef)
@@ -389,6 +389,115 @@
 	}
 }
 
+func TestLegacyAssetToJSON(t *testing.T) {
+	LegacyJSON4Asset = true
+	tests := []struct {
+		in  Asset
+		out string
+	}{
+		// Haven't seen such a thing yet though..
+		{
+			Asset{6000000, Symbol{Precision: 4, Symbol: "EOS"}},
+			"\"600.0000 EOS\"",
+		},
+		{
+			Asset{-6000000, Symbol{Precision: 4, Symbol: "EOS"}},
+			"\"-600.0000 EOS\"",
+		},
+		{
+			Asset{10, Symbol{Precision: 5, Symbol: "SYS"}},
+			"\"0.00010 SYS\"",
+		},
+		{
+			Asset{-10, Symbol{Precision: 5, Symbol: "SYS"}},
+			"\"-0.00010 SYS\"",
+		},
+		{
+			Asset{6000, Symbol{Precision: 0, Symbol: "MAMA"}},
+			"\"6000 MAMA\"",
+		},
+		{
+			Asset{-6000, Symbol{Precision: 0, Symbol: "MAMA"}},
+			"\"-6000 MAMA\"",
+		},
+		{
+			Asset{0, Symbol{Precision: 255, Symbol: "EOS"}},
+			"\"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 EOS\"",
+		},
+	}
+
+	for _, test := range tests {
+		bytes, err := test.in.MarshalJSON()
+		if err != nil {
+			t.Error("MarshalJSON() error: %w", err)
+		}
+		assert.Equal(t, test.out, string(bytes))
+	}
+}
+
+func TestAssetToJSON(t *testing.T) {
+	LegacyJSON4Asset = false
+	tests := []struct {
+		in  Asset
+		out string
+	}{
+		// Haven't seen such a thing yet though..
+		{
+			Asset{6000000, Symbol{Precision: 4, Symbol: "EOS"}},
+			assetJson(t, 600, "EOS", 4),
+		},
+		{
+			Asset{-6000000, Symbol{Precision: 4, Symbol: "EOS"}},
+			assetJson(t, -600, "EOS", 4),
+		},
+		{
+			Asset{10, Symbol{Precision: 5, Symbol: "SYS"}},
+			assetJson(t, 0.0001, "SYS", 5),
+			// "\"0.00010 SYS\"",
+		},
+		{
+			Asset{-10, Symbol{Precision: 5, Symbol: "SYS"}},
+			assetJson(t, -0.0001, "SYS", 5),
+			// "\"-0.00010 SYS\"",
+		},
+		{
+			Asset{6000, Symbol{Precision: 0, Symbol: "MAMA"}},
+			assetJson(t, 6000, "MAMA", 0),
+			// "\"6000 MAMA\"",
+		},
+		{
+			Asset{-6000, Symbol{Precision: 0, Symbol: "MAMA"}},
+			assetJson(t, -6000, "MAMA", 0),
+			// "\"-6000 MAMA\"",
+		},
+		{
+			Asset{0, Symbol{Precision: 255, Symbol: "EOS"}},
+			assetJson(t, 0, "EOS", 255),
+		},
+	}
+
+	for _, test := range tests {
+		bytes, err := test.in.MarshalJSON()
+		if err != nil {
+			t.Error("MarshalJSON() error: %w", err)
+		}
+		assert.Equal(t, test.out, string(bytes))
+	}
+}
+
+func assetJson(t testing.TB, amount float64, symbol string, precision uint8) string {
+	t.Helper()
+	data, err := json.Marshal(map[string]interface{}{
+		"amount":    amount,
+		"symbol":    symbol,
+		"precision": precision,
+	})
+	if err != nil {
+		t.Fatal("json.Marshal error: %w", err)
+	}
+	return string(data)
+}
+
 func TestSimplePacking(t *testing.T) {
 	type S struct {
 		P string
